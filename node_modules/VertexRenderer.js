//VertexRenderer.js
//The VertexRenderer composition takes some vertices and displays them on screen
//Exposes properties such draw mode, fillStyle, or strokeStyle
//fillStyle and strokeStyle can be set to either colors, gradients, or patterns which may be used for interesting effects.

var Composition = require('Composition');
var Canvas = require('Canvas');

module.exports = function(vertices, zIndex, blendMode){
	//Create an empty Composition
	var Renderer = new Composition();

	//Set Renderer.vertices to a new Vertices object
	Renderer.vertices = vertices;

	//Mode can be either 'fill', 'stroke', or 'both'
	Renderer.mode = "fill";

	//Set default fillStyle. Can be color, gradient or pattern
	Renderer.fillStyle = "#000000";

	//Set default strokeStyle. Can be color, gradient or pattern
	Renderer.strokeStyle = "#000000";

	//Set default lineWidth to 1px;
	Renderer.lineWidth = 1;

	//Create canvas
	Renderer.canvas = new Canvas();
	//Set zIndex
	Renderer.canvas.setZIndex(zIndex || 0);
	//Set blendMode
	Renderer.canvas.setBlendMode(blendMode || "normal");

	Renderer.static = true;

	Renderer.start = function(){

		if(this.vertices != null){

			//Start drawing
			this.canvas.context.beginPath();
			this.canvas.context.moveTo(this.vertices.vertices[0].x +
									   this.base.transform.position.x,
									   this.vertices.vertices[0].y +
									   this.base.transform.position.y);

			//Make a line to the next vertex
			for(var vertex = 1; vertex < this.vertices.vertices.length; vertex++){
				this.canvas.context.lineTo(this.vertices.vertices[vertex].x +
										   this.base.transform.position.x,
										   this.vertices.vertices[vertex].y +
										   this.base.transform.position.y);
			}

			this.canvas.context.closePath();

			//Apply draw mode and style
			if(this.mode=="fill"){
				this.canvas.context.fillStyle = this.fillStyle;
				this.canvas.context.fill("nonzero");
			}else if(this.mode=="stroke"){
				this.canvas.context.strokeStyle = this.strokeStyle;
				this.canvas.context.lineWidth = this.lineWidth;
				this.canvas.context.stroke();
			}else if(this.mode=="both"){
				this.canvas.context.fillStyle = this.fillStyle;
				this.canvas.context.fill("nonzero");
				this.canvas.context.strokeStyle = this.strokeStyle;
				this.canvas.context.lineWidth = this.lineWidth;
				this.canvas.context.stroke();
			}
		}
	}
	Renderer.draw = function(timeDelta){
		if(!this.static){
			this.start();
		}
	}
	Renderer.clear = function(){
		if(!this.static){

			//Clear rectangle containing vertices
			this.canvas.context.clearRect(
			 	this.base.transform.position.x + this.vertices.topLeft.x - this.lineWidth,
			 	this.base.transform.position.y + this.vertices.topLeft.y - this.lineWidth,
			 	this.vertices.bottomRight.x-this.vertices.topLeft.x + 2*(this.lineWidth),
			 	this.vertices.bottomRight.y-this.vertices.topLeft.y + 2*(this.lineWidth)
			);
		}
	}

	//Return the created Composition
	return Renderer;
}
