//VertexRenderer.js
//The VertexRenderer composition takes some vertices and displays them on screen
//Exposes properties such draw mode, fillStyle, or strokeStyle
//fillStyle and strokeStyle can be set to either colors, gradients, or patterns which may be used for interesting effects.

var Composition = require('Composition');
var Canvas = require('Canvas');
var Vertices = require('Vertices');

module.exports = function(vertices, zIndex){
	//Create an empty Composition
	var Renderer = new Composition();

	//Set Renderer.vertices to a new Vertices object
	Renderer.vertices = vertices;
	
	//Mode can be either 'fill', 'stroke', or 'both'
	Renderer.mode = "fill";

	//Set default fillStyle. Can be color, gradient or pattern
	Renderer.fillStyle = "#000000";

	//Set default strokeStyle. Can be color, gradient or pattern
	Renderer.strokeStyle = "#000000";

	//Set default lineWidth to 1px;
	Renderer.lineWidth = 1;

	//Create canvas
	Renderer.canvas = new Canvas();
	//Set zIndex
	Renderer.canvas.setZIndex(zIndex || 0);

	Renderer.static = false;

	Renderer.imageData = null;

	Renderer.start = function(){
		if(this.vertices != null){
			for(var polygon = 0; polygon < this.vertices.vertices.length; polygon++){

				//Start drawing
				this.canvas.context.beginPath();
	
				//Move to starting position (the first vertex)
				this.canvas.context.moveTo(this.vertices.vertices[polygon][0].x+this.base.transform.x, this.vertices.vertices[polygon][0].y+this.base.transform.y);
				
				//Make a line to the next vertex
				for(var vertex = 1; vertex < this.vertices.vertices[polygon].length; vertex++){
					this.canvas.context.lineTo(this.vertices.vertices[polygon][vertex].x+this.base.transform.x, this.vertices.vertices[polygon][vertex].y+this.base.transform.y);
				}
	
				
				//Apply draw mode and style
				if(this.mode=="fill"){
					this.canvas.context.fillStyle = this.fillStyle;
					this.canvas.context.fill();
				}else if(this.mode=="stroke"){
					this.canvas.context.strokeStyle = this.strokeStyle;
					this.canvas.context.lineWidth = this.lineWidth;
					this.canvas.context.stroke();
				}else if(this.mode=="both"){
					this.canvas.context.fillStyle = this.fillStyle;
					this.canvas.context.fill();
					this.canvas.context.strokeStyle = this.strokeStyle;
					this.canvas.context.lineWidth = this.lineWidth;
					this.canvas.context.stroke();
				}
	
			}
			
			this.imageData = this.canvas.context.getImageData(0,0,800,500);
		}
	}
	Renderer.draw = function(timeDelta){
		if(!this.static){
			this.start();
		}
	}
	Renderer.clear = function(){
		if(!this.static){
			//Clear rectangle containing vertices
			this.canvas.context.clearRect(
				this.base.transform.x + this.vertices.topLeft.x - 1,
				this.base.transform.y + this.vertices.topLeft.y - 1,
				this.vertices.bottomRight.x - this.vertices.topLeft.x+2,
				this.vertices.bottomRight.y - this.vertices.topLeft.y+2
			);
		}
	}
	
	//Return the created Composition
	return Renderer;
}