var Composition = require('Composition');
var Renderer = require('VertexRenderer');
var Transform = require('Transform');
var Vertices = require('Vertices');
var hueShift = require('hueShift.js');
var Vec2 = require('vec2');

module.exports = function(){
	var terrain = new Composition(
		'transform', Transform(0,0),
		'renderer', Renderer(null, 0)
	);

	terrain.start = function(){
		this.components.renderer.mode = "both";

		//Hue shift
		var self = this;
		hueShift("resources/TempPattern.png", Math.random()*360, function(img){

			//Create Pattern
			var pat = self.components.renderer.canvas.context.createPattern(img,"repeat");

			//Set fillStyle
			self.components.renderer.fillStyle = pat;

			//Super hack that makes it work
			if(self.components.renderer.static){
				self.components.renderer.static = false;
				self.components.renderer.clear();
				self.components.renderer.static = true;
			}

			self.components.renderer.start();
		});

		this.components.renderer.strokeStyle = "#FFFFFF";
		this.components.renderer.lineWidth = 3;

		var baseArray = randomArray(9);

		var vertices = [];
		vertices[0] = new Vec2(0, window.innerHeight);
		for(var i = 0; i <= window.innerWidth/2; i++){
			vertices[i+1] = new Vec2(i*2, noise(baseArray, window.innerWidth, i*2)+window.innerHeight/2);
		}
		vertices[i+1] = new Vec2(window.innerWidth, window.innerHeight);
		this.components.renderer.vertices = new Vertices(vertices);
	}
	return terrain;
}

var cosInterpolate = function(a, b, t){
		var ft = t*Math.PI;
		var f = (1-Math.cos(ft))*0.5;
		return  a*(1-f) + b*f;
	}

var randomArray = function(size){
	var result = [];
	result[0] = Math.random()*2-1;
	for(var i = 1; i < size; i++){
		var r = Math.random()*2-1;
		var e = Math.exp(-Math.pow(r, 2)/2);
		result[i] = result[i-1] + r*e*0.4;
	}
	return result;
}

var noise = function(arrayRandom, size, t){
	var pointCount = arrayRandom.length-1;
	var currentPoint = Math.floor(pointCount*t/size);

	return cosInterpolate(arrayRandom[currentPoint]*100,
						  arrayRandom[currentPoint+1]*100,
						  (t-currentPoint/pointCount*size)/(size/pointCount));
}
